-- ======================================================
-- üõ†Ô∏è BACKEND DEFINITIVO: VENDAF√ÅCIL BRASIL
-- PADR√ÉO RPC-FIRST: TODA L√ìGICA NO POSTGRESQL
-- ======================================================

-- 1Ô∏è‚É£ LIMPEZA: Removendo vers√µes antigas para evitar conflito de assinaturas
DROP FUNCTION IF EXISTS public.rpc_add_item_to_comanda(uuid, uuid, numeric, numeric);
DROP FUNCTION IF EXISTS public.rpc_add_item_to_comanda(uuid, uuid, numeric);
DROP FUNCTION IF EXISTS public.rpc_close_comanda_to_sale(uuid, text, uuid);

-- 2Ô∏è‚É£ FUN√á√ÉO: ADICIONAR ITEM √Ä COMANDA (Vers√£o Est√°vel)
-- ‚úÖ N√ÉO insere na coluna line_total (Postgres calcula automaticamente)
CREATE OR REPLACE FUNCTION public.rpc_add_item_to_comanda(
    p_comanda_id UUID,
    p_product_id UUID,
    p_quantity NUMERIC,
    p_unit_price NUMERIC DEFAULT NULL
) RETURNS TEXT AS $$
DECLARE
    v_store_id UUID;
    v_prod_name TEXT;
    v_prod_target TEXT;
    v_final_price NUMERIC;
BEGIN
    -- 1. Identificar contexto
    SELECT store_id INTO v_store_id FROM public.comandas WHERE id = p_comanda_id;
    SELECT name, production_target INTO v_prod_name, v_prod_target FROM public.products WHERE id = p_product_id;
    
    -- 2. Resolver pre√ßo (Prioridade: Par√¢metro > Cadastro do Produto)
    IF p_unit_price IS NULL OR p_unit_price = 0 THEN
        SELECT price_cents INTO v_final_price FROM public.products WHERE id = p_product_id;
    ELSE
        v_final_price := p_unit_price;
    END IF;

    -- 3. Inserir item (line_total omitido para respeitar GENERATED ALWAYS)
    INSERT INTO public.order_items (
        store_id, comanda_id, product_id, product_name_snapshot,
        quantity, unit_price, status, destino_preparo
    ) VALUES (
        v_store_id, p_comanda_id, p_product_id, v_prod_name,
        p_quantity, v_final_price, 'pending', v_prod_target
    );

    -- 4. Baixa estoque
    UPDATE public.products SET stock_qty = stock_qty - p_quantity WHERE id = p_product_id;
    
    RETURN 'Item lan√ßado com sucesso';
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- 3Ô∏è‚É£ FUN√á√ÉO: CONCLUIR ITEM DE PRODU√á√ÉO (KDS/BDS)
CREATE OR REPLACE FUNCTION public.rpc_mark_order_item_done(
    p_item_id UUID
) RETURNS BOOLEAN AS $$
BEGIN
    UPDATE public.order_items SET status = 'done' WHERE id = p_item_id;
    RETURN FOUND;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- 4Ô∏è‚É£ FUN√á√ÉO: FECHAR COMANDA E GERAR VENDA (At√¥mica)
-- ‚úÖ Utiliza SUM(line_total) para faturamento preciso
CREATE OR REPLACE FUNCTION public.rpc_close_comanda_to_sale(
    p_comanda_id UUID,
    p_payment_method_id TEXT,
    p_cash_register_id UUID DEFAULT NULL
) RETURNS JSONB AS $$
DECLARE
    v_total_cents NUMERIC;
    v_sale_id UUID;
    v_store_id UUID;
    v_register_id UUID;
BEGIN
    SELECT store_id INTO v_store_id FROM public.comandas WHERE id = p_comanda_id;
    
    -- Tenta encontrar caixa aberto se n√£o enviado
    IF p_cash_register_id IS NULL THEN
        SELECT id INTO v_register_id FROM public.cash_registers 
        WHERE store_id = v_store_id AND closed_at IS NULL LIMIT 1;
    ELSE
        v_register_id := p_cash_register_id;
    END IF;

    -- Calcula total baseado na coluna gerada pelo banco
    SELECT COALESCE(SUM(line_total), 0) INTO v_total_cents 
    FROM public.order_items WHERE comanda_id = p_comanda_id AND status != 'canceled';

    -- Cria registro de venda
    INSERT INTO public.sales (
        store_id, comanda_id, total_cents, payment_method, cash_register_id
    ) VALUES (
        v_store_id, p_comanda_id, v_total_cents, p_payment_method_id, v_register_id
    ) RETURNING id INTO v_sale_id;

    -- Vincula itens √† venda e atualiza status
    UPDATE public.order_items SET sale_id = v_sale_id, status = 'done' WHERE comanda_id = p_comanda_id;
    UPDATE public.comandas SET status = 'fechada' WHERE id = p_comanda_id;

    RETURN jsonb_build_object('success', true, 'sale_id', v_sale_id, 'total', v_total_cents);
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;
